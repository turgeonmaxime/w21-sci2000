---
title: "Regular expressions"
draft: true
source: true
output: binb::metropolis
fontsize: 12pt
author: Max Turgeon
institute: SCI 2000--Introduction to Data Science
header-includes:
  - \usefonttheme{professionalfonts}
  - \usepackage{graphicx}
  - \usepackage{tikzpagenodes}
  - \usetikzlibrary{calc}
  - \usepackage{caption}
---

```{r,setup, include=FALSE}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})

knitr::opts_chunk$set(cache = FALSE, message = FALSE,
                      linewidth = 50)
```

## Lecture Objectives

  - Understand the definition of regular expressions
  - Recognize and use the different metacharacters
  - Use regular expressions to filter and edit text data

## Motivation

## Regular expression--Definition

## Applications of regexes

## Example {.allowframebreaks}

```{r}
library(stringr)
```


## Anchors

  - **Anchors** are special characters (i.e. metacharacters) that can be used to specify *where* we want to find a match.
  - There are two main anchors:
    + `^pattern` will match any string that *starts* with `pattern`
    + `pattern$` will match any string that *ends* with `pattern`
  - You can combine them:
    + `^pattern$` will *only* match the string `pattern`
  - If you want to match on a metacharacter (e.g. `$`), you need to escape it (see example below).

## Example {.allowframebreaks}

```{r}
# This doesn't work...
str_detect(c("$15.99", "$3.75", "1.99$"), 
           pattern = "^$")
# But this does!
str_detect(c("$15.99", "$3.75", "1.99$"), 
           pattern = "^\\$")
```

```{r}
# Matching on prices that start or end with dollar sign
# Use logical operator
str_detect(c("$15.99", "$3.75", "1.99$"), 
           pattern = "^\\$") |
  str_detect(c("$15.99", "$3.75", "1.99$"), 
           pattern = "\\$$")
```

## Quantifiers

  - **Quantifiers** are ways to specify how many times a certain pattern should appear.
    + At least once? Exactly three times?
  - There are four important metacharacters to remember.
    + `.` will match any single character, except a new line.
    + `?` will match the item on its left at most once.
    + `*` will match the item on its left zero or more times.
    + `+` will match the item on its left once or more times.
  - Key distinction between `*` and `+`: the latter requires at least one match.
  
## Example {.allowframebreaks}

## Quantifiers cont'd

  - You can also control the number of matches more precisely.
    + `{n}` will match the item on its left exactly n times.
    + `{n,}` will match the item on its left at least n times.
    + `{n,m}` will match the item on its left at least n times, but no more than m times.

## Exercise

<center>
Find a regular expression that matches string ending with an ellipsis (i.e. three dots).
</center>

## Solution

```{r}
str_detect(c("string.", "string..", "string..."),
           pattern = "\\.{3}$")
# Be careful: a string with 4 dots will also match
str_detect("string....", pattern = "\\.{3}$")
```

## Character classes {.allowframebreaks}

  - When discussing quantifiers, I used "item on the left" instead of "character on the left".
  - This was intentional: you can create **character classes** using square brackets.
    + E.g. `p[ao]rt` will match both `part` and `port`.
  - Character classes can also be created using *sequences*.
    + E.g. `[a-z]` will match all lower case letters; `[a-zA-Z]` will match all lower and upper case letters; `[0-9]` will match all ten digits.
    
\vspace{1cm}

  - There are also built-in character classes:
    + `\\d` matches any digit character (equivalent to `[0-9]`)
    + `\\s` matches any space character (including tabs, new lines, etc.)
    + `\\w` matches any word character (equivalent to `[A-Za-z0-9_]`)
    + `\\b` matches word boundaries
  - Finally, you can negate character classes to get non-matches.
    + `p[^ao]rt` matches `purt` and `pert`
    + The negation of `\\d`, `\\s`, `\\w`, `\\b` are `\\D`, `\\S`, `\\W`, `\\B` respectively.

## Example {.allowframebreaks}

```{r}
# Split a sentence into words
str_split("The fox ate a berry.", "\\b")
str_split("The fox ate a berry.", "\\s")
```

```{r}
# Trim white space
str_replace_all("Is  this     enough?", 
                pattern = "\\s+", 
                replacement = " ")
```

## Exercise

<center>
Find a regular expression that matches white space at the beginning and the end of a string. 
</center>

## Solution

```{r}
str_replace_all(" Is this enough?   ",
                pattern = "(^\\s+|\\s+$)",
                replacement = "")
```


## Summary